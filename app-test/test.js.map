{"version":3,"sources":["/app/test.js","/node_modules/angular-mocks/angular-mocks.js"],"names":["require","window","angular","mock","$BrowserProvider","$get","$Browser","self","isMock","$$url","$$lastUrl","pollFns","$$completeOutstandingRequest","noop","$$incOutstandingRequestCount","onUrlChange","listener","push","$$state","$$lastState","$$applicationDestroyed","$$checkUrlChange","deferredFns","deferredNextId","defer","fn","delay","time","now","id","sort","a","b","cancel","deferId","fnIndex","forEach","index","isDefined","splice","flush","nextTime","length","Error","shift","$$baseHref","baseHref","prototype","poll","pollFn","url","replace","state","isUndefined","copy","notifyWhenNoOutstandingRequests","$ExceptionHandlerProvider","handler","mode","errors","e","arguments","slice","call","$LogProvider","debug","concat","array1","array2","Array","debugEnabled","flag","$log","log","logs","warn","info","error","reset","assertEmpty","logLevel","logItem","String","stack","unshift","join","$IntervalProvider","$browser","$rootScope","$q","$$q","repeatFns","nextRepeatId","$interval","count","invokeApply","hasParams","args","iteration","skipApply","deferred","promise","then","apply","$$intervalId","tick","notify","resolve","$apply","reject","millis","task","R_ISO8061_STR","jsonStringToDate","string","match","date","Date","tzHour","tzMin","toInt","setUTCFullYear","setUTCHours","str","parseInt","padNumberInMock","num","digits","trim","neg","substr","TzDate","offset","timestamp","isString","tsStr","origDate","getTime","isNaN","name","message","localOffset","getTimezoneOffset","offsetDiff","toLocaleDateString","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","getDay","toISOString","unimplementedMethods","methodName","animate","module","config","$provide","factory","reflowFn","totalReflows","queue","queueFn","i","decorator","$delegate","runners","animateJsConstructor","animator","$closeAndFlush","runner","end","animateCssConstructor","element","options","$timeout","$$rAF","$animateCss","$$animateJs","$$forceReflow","$$animateAsyncRun","on","off","pin","reflows","enabled","closeAndFlush","hideErrors","$digest","doNextRun","somethingFlushed","method","event","dump","object","serialize","out","isElement","append","clone","html","isArray","o","isObject","isFunction","$eval","serializeScope","toJson","scope","$id","key","Object","hasOwnProperty","child","$$childHead","$$nextSibling","$HttpBackendProvider","createHttpBackendMock","definitions","expectations","responses","responsesPush","bind","createResponse","status","data","headers","statusText","isNumber","$httpBackend","callback","timeout","withCredentials","responseType","eventHandlers","uploadEventHandlers","xhr","MockXhr","expectation","wasExpected","$$events","upload","prettyPrint","RegExp","wrapResponse","wrapped","handleTimeout","handleResponse","response","params","$$respHeaders","getAllResponseHeaders","ii","undefined","matchData","matchHeaders","definition","passThrough","when","keys","MockHttpExpectation","chain","respond","createShortMethods","whenRoute","pathObj","parseRoute","regexp","ret","_","slash","option","optional","star","expect","expectRoute","digest","verifyNoOutstandingExpectation","verifyNoOutstandingRequest","resetExpectations","prefix","getUrlParams","u","indexOf","split","compareUrl","m","d","h","matchUrl","test","equals","fromJson","toString","extend","parseQuery","pathParams","keyObj","exec","len","val","obj","key_value","queryStr","substring","keyValue","tryDecodeURIComponent","value","decodeURIComponent","createMockXhr","$$lastInstance","open","async","$$method","$$async","$$reqHeaders","send","$$data","setRequestHeader","getResponseHeader","header","lowercase","headerVal","headerName","lines","abort","addEventListener","$TimeoutDecorator","verifyNoPendingTasks","formatPendingTasksAsString","tasks","result","$RAFDecorator","rafFn","supported","originalRootElement","$RootElementProvider","$injector","$ControllerDecorator","expression","locals","later","ident","instantiate","instance","$ComponentControllerProvider","$compileProvider","$controller","$componentController","componentName","bindings","directives","get","candidateDirectives","filter","directiveInfo","controller","controllerAs","restrict","$scope","$new","provider","$exceptionHandler","$rootElement","$RootScopeDecorator","injector","e2e","$httpBackendDecorator","$rootScopePrototype","getPrototypeOf","$countChildScopes","countChildScopes","$countWatchers","countWatchers","pendingChildHeads","currentScope","$$watchers","jasmineOrMocha","currentSpec","injectorState","InjectorState","annotatedFunctions","wasInjectorCreated","$$annotate","$inject","moduleFns","workFn","modules","$modules","$providerInjector","invoke","$$beforeAllHook","before","beforeAll","$$afterAllHook","after","afterAll","$$currentSpec","to","sharedInjector","initialized","shared","sharedError","$$cleanup","$$beforeEach","k","$$afterEach","cleanupAfterEach","$$hashKey","rootNode","cleanUpNodes","cleanData","$destroy","fragments","callbacks","$$counter","beforeEach","setup","afterEach","teardown","ErrorAddingDeclarationLocationStack","errorForStack","line","sourceId","stackArray","inject","blockFns","strictDi","$injectorStrict","moduleFn","annotate","jasmine","mocha"],"mappings":"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","file":"test.js","sourcesContent":["require('angular');\nrequire('angular-mocks');\n\n\n/** WEBPACK FOOTER **\n ** ./app/test.js\n **/","/**\n * @license AngularJS v1.5.8\n * (c) 2010-2016 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {\n\n'use strict';\n\n/**\n * @ngdoc object\n * @name angular.mock\n * @description\n *\n * Namespace from 'angular-mocks.js' which contains testing related code.\n *\n */\nangular.mock = {};\n\n/**\n * ! This is a private undocumented service !\n *\n * @name $browser\n *\n * @description\n * This service is a mock implementation of {@link ng.$browser}. It provides fake\n * implementation for commonly used browser apis that are hard to test, e.g. setTimeout, xhr,\n * cookies, etc.\n *\n * The api of this service is the same as that of the real {@link ng.$browser $browser}, except\n * that there are several helper methods available which can be used in tests.\n */\nangular.mock.$BrowserProvider = function() {\n  this.$get = function() {\n    return new angular.mock.$Browser();\n  };\n};\n\nangular.mock.$Browser = function() {\n  var self = this;\n\n  this.isMock = true;\n  self.$$url = \"http://server/\";\n  self.$$lastUrl = self.$$url; // used by url polling fn\n  self.pollFns = [];\n\n  // TODO(vojta): remove this temporary api\n  self.$$completeOutstandingRequest = angular.noop;\n  self.$$incOutstandingRequestCount = angular.noop;\n\n\n  // register url polling fn\n\n  self.onUrlChange = function(listener) {\n    self.pollFns.push(\n      function() {\n        if (self.$$lastUrl !== self.$$url || self.$$state !== self.$$lastState) {\n          self.$$lastUrl = self.$$url;\n          self.$$lastState = self.$$state;\n          listener(self.$$url, self.$$state);\n        }\n      }\n    );\n\n    return listener;\n  };\n\n  self.$$applicationDestroyed = angular.noop;\n  self.$$checkUrlChange = angular.noop;\n\n  self.deferredFns = [];\n  self.deferredNextId = 0;\n\n  self.defer = function(fn, delay) {\n    delay = delay || 0;\n    self.deferredFns.push({time:(self.defer.now + delay), fn:fn, id: self.deferredNextId});\n    self.deferredFns.sort(function(a, b) { return a.time - b.time;});\n    return self.deferredNextId++;\n  };\n\n\n  /**\n   * @name $browser#defer.now\n   *\n   * @description\n   * Current milliseconds mock time.\n   */\n  self.defer.now = 0;\n\n\n  self.defer.cancel = function(deferId) {\n    var fnIndex;\n\n    angular.forEach(self.deferredFns, function(fn, index) {\n      if (fn.id === deferId) fnIndex = index;\n    });\n\n    if (angular.isDefined(fnIndex)) {\n      self.deferredFns.splice(fnIndex, 1);\n      return true;\n    }\n\n    return false;\n  };\n\n\n  /**\n   * @name $browser#defer.flush\n   *\n   * @description\n   * Flushes all pending requests and executes the defer callbacks.\n   *\n   * @param {number=} number of milliseconds to flush. See {@link #defer.now}\n   */\n  self.defer.flush = function(delay) {\n    var nextTime;\n\n    if (angular.isDefined(delay)) {\n      // A delay was passed so compute the next time\n      nextTime = self.defer.now + delay;\n    } else {\n      if (self.deferredFns.length) {\n        // No delay was passed so set the next time so that it clears the deferred queue\n        nextTime = self.deferredFns[self.deferredFns.length - 1].time;\n      } else {\n        // No delay passed, but there are no deferred tasks so flush - indicates an error!\n        throw new Error('No deferred tasks to be flushed');\n      }\n    }\n\n    while (self.deferredFns.length && self.deferredFns[0].time <= nextTime) {\n      // Increment the time and call the next deferred function\n      self.defer.now = self.deferredFns[0].time;\n      self.deferredFns.shift().fn();\n    }\n\n    // Ensure that the current time is correct\n    self.defer.now = nextTime;\n  };\n\n  self.$$baseHref = '/';\n  self.baseHref = function() {\n    return this.$$baseHref;\n  };\n};\nangular.mock.$Browser.prototype = {\n\n  /**\n   * @name $browser#poll\n   *\n   * @description\n   * run all fns in pollFns\n   */\n  poll: function poll() {\n    angular.forEach(this.pollFns, function(pollFn) {\n      pollFn();\n    });\n  },\n\n  url: function(url, replace, state) {\n    if (angular.isUndefined(state)) {\n      state = null;\n    }\n    if (url) {\n      this.$$url = url;\n      // Native pushState serializes & copies the object; simulate it.\n      this.$$state = angular.copy(state);\n      return this;\n    }\n\n    return this.$$url;\n  },\n\n  state: function() {\n    return this.$$state;\n  },\n\n  notifyWhenNoOutstandingRequests: function(fn) {\n    fn();\n  }\n};\n\n\n/**\n * @ngdoc provider\n * @name $exceptionHandlerProvider\n *\n * @description\n * Configures the mock implementation of {@link ng.$exceptionHandler} to rethrow or to log errors\n * passed to the `$exceptionHandler`.\n */\n\n/**\n * @ngdoc service\n * @name $exceptionHandler\n *\n * @description\n * Mock implementation of {@link ng.$exceptionHandler} that rethrows or logs errors passed\n * to it. See {@link ngMock.$exceptionHandlerProvider $exceptionHandlerProvider} for configuration\n * information.\n *\n *\n * ```js\n *   describe('$exceptionHandlerProvider', function() {\n *\n *     it('should capture log messages and exceptions', function() {\n *\n *       module(function($exceptionHandlerProvider) {\n *         $exceptionHandlerProvider.mode('log');\n *       });\n *\n *       inject(function($log, $exceptionHandler, $timeout) {\n *         $timeout(function() { $log.log(1); });\n *         $timeout(function() { $log.log(2); throw 'banana peel'; });\n *         $timeout(function() { $log.log(3); });\n *         expect($exceptionHandler.errors).toEqual([]);\n *         expect($log.assertEmpty());\n *         $timeout.flush();\n *         expect($exceptionHandler.errors).toEqual(['banana peel']);\n *         expect($log.log.logs).toEqual([[1], [2], [3]]);\n *       });\n *     });\n *   });\n * ```\n */\n\nangular.mock.$ExceptionHandlerProvider = function() {\n  var handler;\n\n  /**\n   * @ngdoc method\n   * @name $exceptionHandlerProvider#mode\n   *\n   * @description\n   * Sets the logging mode.\n   *\n   * @param {string} mode Mode of operation, defaults to `rethrow`.\n   *\n   *   - `log`: Sometimes it is desirable to test that an error is thrown, for this case the `log`\n   *     mode stores an array of errors in `$exceptionHandler.errors`, to allow later assertion of\n   *     them. See {@link ngMock.$log#assertEmpty assertEmpty()} and\n   *     {@link ngMock.$log#reset reset()}.\n   *   - `rethrow`: If any errors are passed to the handler in tests, it typically means that there\n   *     is a bug in the application or test, so this mock will make these tests fail. For any\n   *     implementations that expect exceptions to be thrown, the `rethrow` mode will also maintain\n   *     a log of thrown errors in `$exceptionHandler.errors`.\n   */\n  this.mode = function(mode) {\n\n    switch (mode) {\n      case 'log':\n      case 'rethrow':\n        var errors = [];\n        handler = function(e) {\n          if (arguments.length == 1) {\n            errors.push(e);\n          } else {\n            errors.push([].slice.call(arguments, 0));\n          }\n          if (mode === \"rethrow\") {\n            throw e;\n          }\n        };\n        handler.errors = errors;\n        break;\n      default:\n        throw new Error(\"Unknown mode '\" + mode + \"', only 'log'/'rethrow' modes are allowed!\");\n    }\n  };\n\n  this.$get = function() {\n    return handler;\n  };\n\n  this.mode('rethrow');\n};\n\n\n/**\n * @ngdoc service\n * @name $log\n *\n * @description\n * Mock implementation of {@link ng.$log} that gathers all logged messages in arrays\n * (one array per logging level). These arrays are exposed as `logs` property of each of the\n * level-specific log function, e.g. for level `error` the array is exposed as `$log.error.logs`.\n *\n */\nangular.mock.$LogProvider = function() {\n  var debug = true;\n\n  function concat(array1, array2, index) {\n    return array1.concat(Array.prototype.slice.call(array2, index));\n  }\n\n  this.debugEnabled = function(flag) {\n    if (angular.isDefined(flag)) {\n      debug = flag;\n      return this;\n    } else {\n      return debug;\n    }\n  };\n\n  this.$get = function() {\n    var $log = {\n      log: function() { $log.log.logs.push(concat([], arguments, 0)); },\n      warn: function() { $log.warn.logs.push(concat([], arguments, 0)); },\n      info: function() { $log.info.logs.push(concat([], arguments, 0)); },\n      error: function() { $log.error.logs.push(concat([], arguments, 0)); },\n      debug: function() {\n        if (debug) {\n          $log.debug.logs.push(concat([], arguments, 0));\n        }\n      }\n    };\n\n    /**\n     * @ngdoc method\n     * @name $log#reset\n     *\n     * @description\n     * Reset all of the logging arrays to empty.\n     */\n    $log.reset = function() {\n      /**\n       * @ngdoc property\n       * @name $log#log.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#log `log()`}.\n       *\n       * @example\n       * ```js\n       * $log.log('Some Log');\n       * var first = $log.log.logs.unshift();\n       * ```\n       */\n      $log.log.logs = [];\n      /**\n       * @ngdoc property\n       * @name $log#info.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#info `info()`}.\n       *\n       * @example\n       * ```js\n       * $log.info('Some Info');\n       * var first = $log.info.logs.unshift();\n       * ```\n       */\n      $log.info.logs = [];\n      /**\n       * @ngdoc property\n       * @name $log#warn.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#warn `warn()`}.\n       *\n       * @example\n       * ```js\n       * $log.warn('Some Warning');\n       * var first = $log.warn.logs.unshift();\n       * ```\n       */\n      $log.warn.logs = [];\n      /**\n       * @ngdoc property\n       * @name $log#error.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#error `error()`}.\n       *\n       * @example\n       * ```js\n       * $log.error('Some Error');\n       * var first = $log.error.logs.unshift();\n       * ```\n       */\n      $log.error.logs = [];\n        /**\n       * @ngdoc property\n       * @name $log#debug.logs\n       *\n       * @description\n       * Array of messages logged using {@link ng.$log#debug `debug()`}.\n       *\n       * @example\n       * ```js\n       * $log.debug('Some Error');\n       * var first = $log.debug.logs.unshift();\n       * ```\n       */\n      $log.debug.logs = [];\n    };\n\n    /**\n     * @ngdoc method\n     * @name $log#assertEmpty\n     *\n     * @description\n     * Assert that all of the logging methods have no logged messages. If any messages are present,\n     * an exception is thrown.\n     */\n    $log.assertEmpty = function() {\n      var errors = [];\n      angular.forEach(['error', 'warn', 'info', 'log', 'debug'], function(logLevel) {\n        angular.forEach($log[logLevel].logs, function(log) {\n          angular.forEach(log, function(logItem) {\n            errors.push('MOCK $log (' + logLevel + '): ' + String(logItem) + '\\n' +\n                        (logItem.stack || ''));\n          });\n        });\n      });\n      if (errors.length) {\n        errors.unshift(\"Expected $log to be empty! Either a message was logged unexpectedly, or \" +\n          \"an expected log message was not checked and removed:\");\n        errors.push('');\n        throw new Error(errors.join('\\n---------\\n'));\n      }\n    };\n\n    $log.reset();\n    return $log;\n  };\n};\n\n\n/**\n * @ngdoc service\n * @name $interval\n *\n * @description\n * Mock implementation of the $interval service.\n *\n * Use {@link ngMock.$interval#flush `$interval.flush(millis)`} to\n * move forward by `millis` milliseconds and trigger any functions scheduled to run in that\n * time.\n *\n * @param {function()} fn A function that should be called repeatedly.\n * @param {number} delay Number of milliseconds between each function call.\n * @param {number=} [count=0] Number of times to repeat. If not set, or 0, will repeat\n *   indefinitely.\n * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise\n *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.\n * @param {...*=} Pass additional parameters to the executed function.\n * @returns {promise} A promise which will be notified on each iteration.\n */\nangular.mock.$IntervalProvider = function() {\n  this.$get = ['$browser', '$rootScope', '$q', '$$q',\n       function($browser,   $rootScope,   $q,   $$q) {\n    var repeatFns = [],\n        nextRepeatId = 0,\n        now = 0;\n\n    var $interval = function(fn, delay, count, invokeApply) {\n      var hasParams = arguments.length > 4,\n          args = hasParams ? Array.prototype.slice.call(arguments, 4) : [],\n          iteration = 0,\n          skipApply = (angular.isDefined(invokeApply) && !invokeApply),\n          deferred = (skipApply ? $$q : $q).defer(),\n          promise = deferred.promise;\n\n      count = (angular.isDefined(count)) ? count : 0;\n      promise.then(null, null, (!hasParams) ? fn : function() {\n        fn.apply(null, args);\n      });\n\n      promise.$$intervalId = nextRepeatId;\n\n      function tick() {\n        deferred.notify(iteration++);\n\n        if (count > 0 && iteration >= count) {\n          var fnIndex;\n          deferred.resolve(iteration);\n\n          angular.forEach(repeatFns, function(fn, index) {\n            if (fn.id === promise.$$intervalId) fnIndex = index;\n          });\n\n          if (angular.isDefined(fnIndex)) {\n            repeatFns.splice(fnIndex, 1);\n          }\n        }\n\n        if (skipApply) {\n          $browser.defer.flush();\n        } else {\n          $rootScope.$apply();\n        }\n      }\n\n      repeatFns.push({\n        nextTime:(now + delay),\n        delay: delay,\n        fn: tick,\n        id: nextRepeatId,\n        deferred: deferred\n      });\n      repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\n\n      nextRepeatId++;\n      return promise;\n    };\n    /**\n     * @ngdoc method\n     * @name $interval#cancel\n     *\n     * @description\n     * Cancels a task associated with the `promise`.\n     *\n     * @param {promise} promise A promise from calling the `$interval` function.\n     * @returns {boolean} Returns `true` if the task was successfully cancelled.\n     */\n    $interval.cancel = function(promise) {\n      if (!promise) return false;\n      var fnIndex;\n\n      angular.forEach(repeatFns, function(fn, index) {\n        if (fn.id === promise.$$intervalId) fnIndex = index;\n      });\n\n      if (angular.isDefined(fnIndex)) {\n        repeatFns[fnIndex].deferred.reject('canceled');\n        repeatFns.splice(fnIndex, 1);\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @ngdoc method\n     * @name $interval#flush\n     * @description\n     *\n     * Runs interval tasks scheduled to be run in the next `millis` milliseconds.\n     *\n     * @param {number=} millis maximum timeout amount to flush up until.\n     *\n     * @return {number} The amount of time moved forward.\n     */\n    $interval.flush = function(millis) {\n      now += millis;\n      while (repeatFns.length && repeatFns[0].nextTime <= now) {\n        var task = repeatFns[0];\n        task.fn();\n        task.nextTime += task.delay;\n        repeatFns.sort(function(a, b) { return a.nextTime - b.nextTime;});\n      }\n      return millis;\n    };\n\n    return $interval;\n  }];\n};\n\n\n/* jshint -W101 */\n/* The R_ISO8061_STR regex is never going to fit into the 100 char limit!\n * This directive should go inside the anonymous function but a bug in JSHint means that it would\n * not be enacted early enough to prevent the warning.\n */\nvar R_ISO8061_STR = /^(-?\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?:\\:?(\\d\\d)(?:\\:?(\\d\\d)(?:\\.(\\d{3}))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d)))?$/;\n\nfunction jsonStringToDate(string) {\n  var match;\n  if (match = string.match(R_ISO8061_STR)) {\n    var date = new Date(0),\n        tzHour = 0,\n        tzMin  = 0;\n    if (match[9]) {\n      tzHour = toInt(match[9] + match[10]);\n      tzMin = toInt(match[9] + match[11]);\n    }\n    date.setUTCFullYear(toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));\n    date.setUTCHours(toInt(match[4] || 0) - tzHour,\n                     toInt(match[5] || 0) - tzMin,\n                     toInt(match[6] || 0),\n                     toInt(match[7] || 0));\n    return date;\n  }\n  return string;\n}\n\nfunction toInt(str) {\n  return parseInt(str, 10);\n}\n\nfunction padNumberInMock(num, digits, trim) {\n  var neg = '';\n  if (num < 0) {\n    neg =  '-';\n    num = -num;\n  }\n  num = '' + num;\n  while (num.length < digits) num = '0' + num;\n  if (trim) {\n    num = num.substr(num.length - digits);\n  }\n  return neg + num;\n}\n\n\n/**\n * @ngdoc type\n * @name angular.mock.TzDate\n * @description\n *\n * *NOTE*: this is not an injectable instance, just a globally available mock class of `Date`.\n *\n * Mock of the Date type which has its timezone specified via constructor arg.\n *\n * The main purpose is to create Date-like instances with timezone fixed to the specified timezone\n * offset, so that we can test code that depends on local timezone settings without dependency on\n * the time zone settings of the machine where the code is running.\n *\n * @param {number} offset Offset of the *desired* timezone in hours (fractions will be honored)\n * @param {(number|string)} timestamp Timestamp representing the desired time in *UTC*\n *\n * @example\n * !!!! WARNING !!!!!\n * This is not a complete Date object so only methods that were implemented can be called safely.\n * To make matters worse, TzDate instances inherit stuff from Date via a prototype.\n *\n * We do our best to intercept calls to \"unimplemented\" methods, but since the list of methods is\n * incomplete we might be missing some non-standard methods. This can result in errors like:\n * \"Date.prototype.foo called on incompatible Object\".\n *\n * ```js\n * var newYearInBratislava = new TzDate(-1, '2009-12-31T23:00:00Z');\n * newYearInBratislava.getTimezoneOffset() => -60;\n * newYearInBratislava.getFullYear() => 2010;\n * newYearInBratislava.getMonth() => 0;\n * newYearInBratislava.getDate() => 1;\n * newYearInBratislava.getHours() => 0;\n * newYearInBratislava.getMinutes() => 0;\n * newYearInBratislava.getSeconds() => 0;\n * ```\n *\n */\nangular.mock.TzDate = function(offset, timestamp) {\n  var self = new Date(0);\n  if (angular.isString(timestamp)) {\n    var tsStr = timestamp;\n\n    self.origDate = jsonStringToDate(timestamp);\n\n    timestamp = self.origDate.getTime();\n    if (isNaN(timestamp)) {\n      throw {\n        name: \"Illegal Argument\",\n        message: \"Arg '\" + tsStr + \"' passed into TzDate constructor is not a valid date string\"\n      };\n    }\n  } else {\n    self.origDate = new Date(timestamp);\n  }\n\n  var localOffset = new Date(timestamp).getTimezoneOffset();\n  self.offsetDiff = localOffset * 60 * 1000 - offset * 1000 * 60 * 60;\n  self.date = new Date(timestamp + self.offsetDiff);\n\n  self.getTime = function() {\n    return self.date.getTime() - self.offsetDiff;\n  };\n\n  self.toLocaleDateString = function() {\n    return self.date.toLocaleDateString();\n  };\n\n  self.getFullYear = function() {\n    return self.date.getFullYear();\n  };\n\n  self.getMonth = function() {\n    return self.date.getMonth();\n  };\n\n  self.getDate = function() {\n    return self.date.getDate();\n  };\n\n  self.getHours = function() {\n    return self.date.getHours();\n  };\n\n  self.getMinutes = function() {\n    return self.date.getMinutes();\n  };\n\n  self.getSeconds = function() {\n    return self.date.getSeconds();\n  };\n\n  self.getMilliseconds = function() {\n    return self.date.getMilliseconds();\n  };\n\n  self.getTimezoneOffset = function() {\n    return offset * 60;\n  };\n\n  self.getUTCFullYear = function() {\n    return self.origDate.getUTCFullYear();\n  };\n\n  self.getUTCMonth = function() {\n    return self.origDate.getUTCMonth();\n  };\n\n  self.getUTCDate = function() {\n    return self.origDate.getUTCDate();\n  };\n\n  self.getUTCHours = function() {\n    return self.origDate.getUTCHours();\n  };\n\n  self.getUTCMinutes = function() {\n    return self.origDate.getUTCMinutes();\n  };\n\n  self.getUTCSeconds = function() {\n    return self.origDate.getUTCSeconds();\n  };\n\n  self.getUTCMilliseconds = function() {\n    return self.origDate.getUTCMilliseconds();\n  };\n\n  self.getDay = function() {\n    return self.date.getDay();\n  };\n\n  // provide this method only on browsers that already have it\n  if (self.toISOString) {\n    self.toISOString = function() {\n      return padNumberInMock(self.origDate.getUTCFullYear(), 4) + '-' +\n            padNumberInMock(self.origDate.getUTCMonth() + 1, 2) + '-' +\n            padNumberInMock(self.origDate.getUTCDate(), 2) + 'T' +\n            padNumberInMock(self.origDate.getUTCHours(), 2) + ':' +\n            padNumberInMock(self.origDate.getUTCMinutes(), 2) + ':' +\n            padNumberInMock(self.origDate.getUTCSeconds(), 2) + '.' +\n            padNumberInMock(self.origDate.getUTCMilliseconds(), 3) + 'Z';\n    };\n  }\n\n  //hide all methods not implemented in this mock that the Date prototype exposes\n  var unimplementedMethods = ['getUTCDay',\n      'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds',\n      'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear',\n      'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds',\n      'setYear', 'toDateString', 'toGMTString', 'toJSON', 'toLocaleFormat', 'toLocaleString',\n      'toLocaleTimeString', 'toSource', 'toString', 'toTimeString', 'toUTCString', 'valueOf'];\n\n  angular.forEach(unimplementedMethods, function(methodName) {\n    self[methodName] = function() {\n      throw new Error(\"Method '\" + methodName + \"' is not implemented in the TzDate mock\");\n    };\n  });\n\n  return self;\n};\n\n//make \"tzDateInstance instanceof Date\" return true\nangular.mock.TzDate.prototype = Date.prototype;\n/* jshint +W101 */\n\n\n/**\n * @ngdoc service\n * @name $animate\n *\n * @description\n * Mock implementation of the {@link ng.$animate `$animate`} service. Exposes two additional methods\n * for testing animations.\n *\n * You need to require the `ngAnimateMock` module in your test suite for instance `beforeEach(module('ngAnimateMock'))`\n */\nangular.mock.animate = angular.module('ngAnimateMock', ['ng'])\n\n  .config(['$provide', function($provide) {\n\n    $provide.factory('$$forceReflow', function() {\n      function reflowFn() {\n        reflowFn.totalReflows++;\n      }\n      reflowFn.totalReflows = 0;\n      return reflowFn;\n    });\n\n    $provide.factory('$$animateAsyncRun', function() {\n      var queue = [];\n      var queueFn = function() {\n        return function(fn) {\n          queue.push(fn);\n        };\n      };\n      queueFn.flush = function() {\n        if (queue.length === 0) return false;\n\n        for (var i = 0; i < queue.length; i++) {\n          queue[i]();\n        }\n        queue = [];\n\n        return true;\n      };\n      return queueFn;\n    });\n\n    $provide.decorator('$$animateJs', ['$delegate', function($delegate) {\n      var runners = [];\n\n      var animateJsConstructor = function() {\n        var animator = $delegate.apply($delegate, arguments);\n        // If no javascript animation is found, animator is undefined\n        if (animator) {\n          runners.push(animator);\n        }\n        return animator;\n      };\n\n      animateJsConstructor.$closeAndFlush = function() {\n        runners.forEach(function(runner) {\n          runner.end();\n        });\n        runners = [];\n      };\n\n      return animateJsConstructor;\n    }]);\n\n    $provide.decorator('$animateCss', ['$delegate', function($delegate) {\n      var runners = [];\n\n      var animateCssConstructor = function(element, options) {\n        var animator = $delegate(element, options);\n        runners.push(animator);\n        return animator;\n      };\n\n      animateCssConstructor.$closeAndFlush = function() {\n        runners.forEach(function(runner) {\n          runner.end();\n        });\n        runners = [];\n      };\n\n      return animateCssConstructor;\n    }]);\n\n    $provide.decorator('$animate', ['$delegate', '$timeout', '$browser', '$$rAF', '$animateCss', '$$animateJs',\n                                    '$$forceReflow', '$$animateAsyncRun', '$rootScope',\n                            function($delegate,   $timeout,   $browser,   $$rAF,   $animateCss,   $$animateJs,\n                                     $$forceReflow,   $$animateAsyncRun,  $rootScope) {\n      var animate = {\n        queue: [],\n        cancel: $delegate.cancel,\n        on: $delegate.on,\n        off: $delegate.off,\n        pin: $delegate.pin,\n        get reflows() {\n          return $$forceReflow.totalReflows;\n        },\n        enabled: $delegate.enabled,\n        /**\n         * @ngdoc method\n         * @name $animate#closeAndFlush\n         * @description\n         *\n         * This method will close all pending animations (both {@link ngAnimate#javascript-based-animations Javascript}\n         * and {@link ngAnimate.$animateCss CSS}) and it will also flush any remaining animation frames and/or callbacks.\n         */\n        closeAndFlush: function() {\n          // we allow the flush command to swallow the errors\n          // because depending on whether CSS or JS animations are\n          // used, there may not be a RAF flush. The primary flush\n          // at the end of this function must throw an exception\n          // because it will track if there were pending animations\n          this.flush(true);\n          $animateCss.$closeAndFlush();\n          $$animateJs.$closeAndFlush();\n          this.flush();\n        },\n        /**\n         * @ngdoc method\n         * @name $animate#flush\n         * @description\n         *\n         * This method is used to flush the pending callbacks and animation frames to either start\n         * an animation or conclude an animation. Note that this will not actually close an\n         * actively running animation (see {@link ngMock.$animate#closeAndFlush `closeAndFlush()`} for that).\n         */\n        flush: function(hideErrors) {\n          $rootScope.$digest();\n\n          var doNextRun, somethingFlushed = false;\n          do {\n            doNextRun = false;\n\n            if ($$rAF.queue.length) {\n              $$rAF.flush();\n              doNextRun = somethingFlushed = true;\n            }\n\n            if ($$animateAsyncRun.flush()) {\n              doNextRun = somethingFlushed = true;\n            }\n          } while (doNextRun);\n\n          if (!somethingFlushed && !hideErrors) {\n            throw new Error('No pending animations ready to be closed or flushed');\n          }\n\n          $rootScope.$digest();\n        }\n      };\n\n      angular.forEach(\n        ['animate','enter','leave','move','addClass','removeClass','setClass'], function(method) {\n        animate[method] = function() {\n          animate.queue.push({\n            event: method,\n            element: arguments[0],\n            options: arguments[arguments.length - 1],\n            args: arguments\n          });\n          return $delegate[method].apply($delegate, arguments);\n        };\n      });\n\n      return animate;\n    }]);\n\n  }]);\n\n\n/**\n * @ngdoc function\n * @name angular.mock.dump\n * @description\n *\n * *NOTE*: This is not an injectable instance, just a globally available function.\n *\n * Method for serializing common angular objects (scope, elements, etc..) into strings.\n * It is useful for logging objects to the console when debugging.\n *\n * @param {*} object - any object to turn into string.\n * @return {string} a serialized string of the argument\n */\nangular.mock.dump = function(object) {\n  return serialize(object);\n\n  function serialize(object) {\n    var out;\n\n    if (angular.isElement(object)) {\n      object = angular.element(object);\n      out = angular.element('<div></div>');\n      angular.forEach(object, function(element) {\n        out.append(angular.element(element).clone());\n      });\n      out = out.html();\n    } else if (angular.isArray(object)) {\n      out = [];\n      angular.forEach(object, function(o) {\n        out.push(serialize(o));\n      });\n      out = '[ ' + out.join(', ') + ' ]';\n    } else if (angular.isObject(object)) {\n      if (angular.isFunction(object.$eval) && angular.isFunction(object.$apply)) {\n        out = serializeScope(object);\n      } else if (object instanceof Error) {\n        out = object.stack || ('' + object.name + ': ' + object.message);\n      } else {\n        // TODO(i): this prevents methods being logged,\n        // we should have a better way to serialize objects\n        out = angular.toJson(object, true);\n      }\n    } else {\n      out = String(object);\n    }\n\n    return out;\n  }\n\n  function serializeScope(scope, offset) {\n    offset = offset ||  '  ';\n    var log = [offset + 'Scope(' + scope.$id + '): {'];\n    for (var key in scope) {\n      if (Object.prototype.hasOwnProperty.call(scope, key) && !key.match(/^(\\$|this)/)) {\n        log.push('  ' + key + ': ' + angular.toJson(scope[key]));\n      }\n    }\n    var child = scope.$$childHead;\n    while (child) {\n      log.push(serializeScope(child, offset + '  '));\n      child = child.$$nextSibling;\n    }\n    log.push('}');\n    return log.join('\\n' + offset);\n  }\n};\n\n/**\n * @ngdoc service\n * @name $httpBackend\n * @description\n * Fake HTTP backend implementation suitable for unit testing applications that use the\n * {@link ng.$http $http service}.\n *\n * <div class=\"alert alert-info\">\n * **Note**: For fake HTTP backend implementation suitable for end-to-end testing or backend-less\n * development please see {@link ngMockE2E.$httpBackend e2e $httpBackend mock}.\n * </div>\n *\n * During unit testing, we want our unit tests to run quickly and have no external dependencies so\n * we don’t want to send [XHR](https://developer.mozilla.org/en/xmlhttprequest) or\n * [JSONP](http://en.wikipedia.org/wiki/JSONP) requests to a real server. All we really need is\n * to verify whether a certain request has been sent or not, or alternatively just let the\n * application make requests, respond with pre-trained responses and assert that the end result is\n * what we expect it to be.\n *\n * This mock implementation can be used to respond with static or dynamic responses via the\n * `expect` and `when` apis and their shortcuts (`expectGET`, `whenPOST`, etc).\n *\n * When an Angular application needs some data from a server, it calls the $http service, which\n * sends the request to a real server using $httpBackend service. With dependency injection, it is\n * easy to inject $httpBackend mock (which has the same API as $httpBackend) and use it to verify\n * the requests and respond with some testing data without sending a request to a real server.\n *\n * There are two ways to specify what test data should be returned as http responses by the mock\n * backend when the code under test makes http requests:\n *\n * - `$httpBackend.expect` - specifies a request expectation\n * - `$httpBackend.when` - specifies a backend definition\n *\n *\n * ## Request Expectations vs Backend Definitions\n *\n * Request expectations provide a way to make assertions about requests made by the application and\n * to define responses for those requests. The test will fail if the expected requests are not made\n * or they are made in the wrong order.\n *\n * Backend definitions allow you to define a fake backend for your application which doesn't assert\n * if a particular request was made or not, it just returns a trained response if a request is made.\n * The test will pass whether or not the request gets made during testing.\n *\n *\n * <table class=\"table\">\n *   <tr><th width=\"220px\"></th><th>Request expectations</th><th>Backend definitions</th></tr>\n *   <tr>\n *     <th>Syntax</th>\n *     <td>.expect(...).respond(...)</td>\n *     <td>.when(...).respond(...)</td>\n *   </tr>\n *   <tr>\n *     <th>Typical usage</th>\n *     <td>strict unit tests</td>\n *     <td>loose (black-box) unit testing</td>\n *   </tr>\n *   <tr>\n *     <th>Fulfills multiple requests</th>\n *     <td>NO</td>\n *     <td>YES</td>\n *   </tr>\n *   <tr>\n *     <th>Order of requests matters</th>\n *     <td>YES</td>\n *     <td>NO</td>\n *   </tr>\n *   <tr>\n *     <th>Request required</th>\n *     <td>YES</td>\n *     <td>NO</td>\n *   </tr>\n *   <tr>\n *     <th>Response required</th>\n *     <td>optional (see below)</td>\n *     <td>YES</td>\n *   </tr>\n * </table>\n *\n * In cases where both backend definitions and request expectations are specified during unit\n * testing, the request expectations are evaluated first.\n *\n * If a request expectation has no response specified, the algorithm will search your backend\n * definitions for an appropriate response.\n *\n * If a request didn't match any expectation or if the expectation doesn't have the response\n * defined, the backend definitions are evaluated in sequential order to see if any of them match\n * the request. The response from the first matched definition is returned.\n *\n *\n * ## Flushing HTTP requests\n *\n * The $httpBackend used in production always responds to requests asynchronously. If we preserved\n * this behavior in unit testing, we'd have to create async unit tests, which are hard to write,\n * to follow and to maintain. But neither can the testing mock respond synchronously; that would\n * change the execution of the code under test. For this reason, the mock $httpBackend has a\n * `flush()` method, which allows the test to explicitly flush pending requests. This preserves\n * the async api of the backend, while allowing the test to execute synchronously.\n *\n *\n * ## Unit testing with mock $httpBackend\n * The following code shows how to setup and use the mock backend when unit testing a controller.\n * First we create the controller under test:\n *\n  ```js\n  // The module code\n  angular\n    .module('MyApp', [])\n    .controller('MyController', MyController);\n\n  // The controller code\n  function MyController($scope, $http) {\n    var authToken;\n\n    $http.get('/auth.py').then(function(response) {\n      authToken = response.headers('A-Token');\n      $scope.user = response.data;\n    });\n\n    $scope.saveMessage = function(message) {\n      var headers = { 'Authorization': authToken };\n      $scope.status = 'Saving...';\n\n      $http.post('/add-msg.py', message, { headers: headers } ).then(function(response) {\n        $scope.status = '';\n      }).catch(function() {\n        $scope.status = 'Failed...';\n      });\n    };\n  }\n  ```\n *\n * Now we setup the mock backend and create the test specs:\n *\n  ```js\n    // testing controller\n    describe('MyController', function() {\n       var $httpBackend, $rootScope, createController, authRequestHandler;\n\n       // Set up the module\n       beforeEach(module('MyApp'));\n\n       beforeEach(inject(function($injector) {\n         // Set up the mock http service responses\n         $httpBackend = $injector.get('$httpBackend');\n         // backend definition common for all tests\n         authRequestHandler = $httpBackend.when('GET', '/auth.py')\n                                .respond({userId: 'userX'}, {'A-Token': 'xxx'});\n\n         // Get hold of a scope (i.e. the root scope)\n         $rootScope = $injector.get('$rootScope');\n         // The $controller service is used to create instances of controllers\n         var $controller = $injector.get('$controller');\n\n         createController = function() {\n           return $controller('MyController', {'$scope' : $rootScope });\n         };\n       }));\n\n\n       afterEach(function() {\n         $httpBackend.verifyNoOutstandingExpectation();\n         $httpBackend.verifyNoOutstandingRequest();\n       });\n\n\n       it('should fetch authentication token', function() {\n         $httpBackend.expectGET('/auth.py');\n         var controller = createController();\n         $httpBackend.flush();\n       });\n\n\n       it('should fail authentication', function() {\n\n         // Notice how you can change the response even after it was set\n         authRequestHandler.respond(401, '');\n\n         $httpBackend.expectGET('/auth.py');\n         var controller = createController();\n         $httpBackend.flush();\n         expect($rootScope.status).toBe('Failed...');\n       });\n\n\n       it('should send msg to server', function() {\n         var controller = createController();\n         $httpBackend.flush();\n\n         // now you don’t care about the authentication, but\n         // the controller will still send the request and\n         // $httpBackend will respond without you having to\n         // specify the expectation and response for this request\n\n         $httpBackend.expectPOST('/add-msg.py', 'message content').respond(201, '');\n         $rootScope.saveMessage('message content');\n         expect($rootScope.status).toBe('Saving...');\n         $httpBackend.flush();\n         expect($rootScope.status).toBe('');\n       });\n\n\n       it('should send auth header', function() {\n         var controller = createController();\n         $httpBackend.flush();\n\n         $httpBackend.expectPOST('/add-msg.py', undefined, function(headers) {\n           // check if the header was sent, if it wasn't the expectation won't\n           // match the request and the test will fail\n           return headers['Authorization'] == 'xxx';\n         }).respond(201, '');\n\n         $rootScope.saveMessage('whatever');\n         $httpBackend.flush();\n       });\n    });\n  ```\n *\n * ## Dynamic responses\n *\n * You define a response to a request by chaining a call to `respond()` onto a definition or expectation.\n * If you provide a **callback** as the first parameter to `respond(callback)` then you can dynamically generate\n * a response based on the properties of the request.\n *\n * The `callback` function should be of the form `function(method, url, data, headers, params)`.\n *\n * ### Query parameters\n *\n * By default, query parameters on request URLs are parsed into the `params` object. So a request URL\n * of `/list?q=searchstr&orderby=-name` would set `params` to be `{q: 'searchstr', orderby: '-name'}`.\n *\n * ### Regex parameter matching\n *\n * If an expectation or definition uses a **regex** to match the URL, you can provide an array of **keys** via a\n * `params` argument. The index of each **key** in the array will match the index of a **group** in the\n * **regex**.\n *\n * The `params` object in the **callback** will now have properties with these keys, which hold the value of the\n * corresponding **group** in the **regex**.\n *\n * This also applies to the `when` and `expect` shortcut methods.\n *\n *\n * ```js\n *   $httpBackend.expect('GET', /\\/user\\/(.+)/, undefined, undefined, ['id'])\n *     .respond(function(method, url, data, headers, params) {\n *       // for requested url of '/user/1234' params is {id: '1234'}\n *     });\n *\n *   $httpBackend.whenPATCH(/\\/user\\/(.+)\\/article\\/(.+)/, undefined, undefined, ['user', 'article'])\n *     .respond(function(method, url, data, headers, params) {\n *       // for url of '/user/1234/article/567' params is {user: '1234', article: '567'}\n *     });\n * ```\n *\n * ## Matching route requests\n *\n * For extra convenience, `whenRoute` and `expectRoute` shortcuts are available. These methods offer colon\n * delimited matching of the url path, ignoring the query string. This allows declarations\n * similar to how application routes are configured with `$routeProvider`. Because these methods convert\n * the definition url to regex, declaration order is important. Combined with query parameter parsing,\n * the following is possible:\n *\n  ```js\n    $httpBackend.whenRoute('GET', '/users/:id')\n      .respond(function(method, url, data, headers, params) {\n        return [200, MockUserList[Number(params.id)]];\n      });\n\n    $httpBackend.whenRoute('GET', '/users')\n      .respond(function(method, url, data, headers, params) {\n        var userList = angular.copy(MockUserList),\n          defaultSort = 'lastName',\n          count, pages, isPrevious, isNext;\n\n        // paged api response '/v1/users?page=2'\n        params.page = Number(params.page) || 1;\n\n        // query for last names '/v1/users?q=Archer'\n        if (params.q) {\n          userList = $filter('filter')({lastName: params.q});\n        }\n\n        pages = Math.ceil(userList.length / pagingLength);\n        isPrevious = params.page > 1;\n        isNext = params.page < pages;\n\n        return [200, {\n          count:    userList.length,\n          previous: isPrevious,\n          next:     isNext,\n          // sort field -> '/v1/users?sortBy=firstName'\n          results:  $filter('orderBy')(userList, params.sortBy || defaultSort)\n                      .splice((params.page - 1) * pagingLength, pagingLength)\n        }];\n      });\n  ```\n */\nangular.mock.$HttpBackendProvider = function() {\n  this.$get = ['$rootScope', '$timeout', createHttpBackendMock];\n};\n\n/**\n * General factory function for $httpBackend mock.\n * Returns instance for unit testing (when no arguments specified):\n *   - passing through is disabled\n *   - auto flushing is disabled\n *\n * Returns instance for e2e testing (when `$delegate` and `$browser` specified):\n *   - passing through (delegating request to real backend) is enabled\n *   - auto flushing is enabled\n *\n * @param {Object=} $delegate Real $httpBackend instance (allow passing through if specified)\n * @param {Object=} $browser Auto-flushing enabled if specified\n * @return {Object} Instance of $httpBackend mock\n */\nfunction createHttpBackendMock($rootScope, $timeout, $delegate, $browser) {\n  var definitions = [],\n      expectations = [],\n      responses = [],\n      responsesPush = angular.bind(responses, responses.push),\n      copy = angular.copy;\n\n  function createResponse(status, data, headers, statusText) {\n    if (angular.isFunction(status)) return status;\n\n    return function() {\n      return angular.isNumber(status)\n          ? [status, data, headers, statusText]\n          : [200, status, data, headers];\n    };\n  }\n\n  // TODO(vojta): change params to: method, url, data, headers, callback\n  function $httpBackend(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {\n\n    var xhr = new MockXhr(),\n        expectation = expectations[0],\n        wasExpected = false;\n\n    xhr.$$events = eventHandlers;\n    xhr.upload.$$events = uploadEventHandlers;\n\n    function prettyPrint(data) {\n      return (angular.isString(data) || angular.isFunction(data) || data instanceof RegExp)\n          ? data\n          : angular.toJson(data);\n    }\n\n    function wrapResponse(wrapped) {\n      if (!$browser && timeout) {\n        timeout.then ? timeout.then(handleTimeout) : $timeout(handleTimeout, timeout);\n      }\n\n      return handleResponse;\n\n      function handleResponse() {\n        var response = wrapped.response(method, url, data, headers, wrapped.params(url));\n        xhr.$$respHeaders = response[2];\n        callback(copy(response[0]), copy(response[1]), xhr.getAllResponseHeaders(),\n                 copy(response[3] || ''));\n      }\n\n      function handleTimeout() {\n        for (var i = 0, ii = responses.length; i < ii; i++) {\n          if (responses[i] === handleResponse) {\n            responses.splice(i, 1);\n            callback(-1, undefined, '');\n            break;\n          }\n        }\n      }\n    }\n\n    if (expectation && expectation.match(method, url)) {\n      if (!expectation.matchData(data)) {\n        throw new Error('Expected ' + expectation + ' with different data\\n' +\n            'EXPECTED: ' + prettyPrint(expectation.data) + '\\nGOT:      ' + data);\n      }\n\n      if (!expectation.matchHeaders(headers)) {\n        throw new Error('Expected ' + expectation + ' with different headers\\n' +\n                        'EXPECTED: ' + prettyPrint(expectation.headers) + '\\nGOT:      ' +\n                        prettyPrint(headers));\n      }\n\n      expectations.shift();\n\n      if (expectation.response) {\n        responses.push(wrapResponse(expectation));\n        return;\n      }\n      wasExpected = true;\n    }\n\n    var i = -1, definition;\n    while ((definition = definitions[++i])) {\n      if (definition.match(method, url, data, headers || {})) {\n        if (definition.response) {\n          // if $browser specified, we do auto flush all requests\n          ($browser ? $browser.defer : responsesPush)(wrapResponse(definition));\n        } else if (definition.passThrough) {\n          $delegate(method, url, data, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers);\n        } else throw new Error('No response defined !');\n        return;\n      }\n    }\n    throw wasExpected ?\n        new Error('No response defined !') :\n        new Error('Unexpected request: ' + method + ' ' + url + '\\n' +\n                  (expectation ? 'Expected ' + expectation : 'No more request expected'));\n  }\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#when\n   * @description\n   * Creates a new backend definition.\n   *\n   * @param {string} method HTTP method.\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n   *   data string and returns true if the data is as expected.\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\n   *   object and returns true if the headers match the current definition.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   *\n   *  - respond –\n   *      ```js\n   *      {function([status,] data[, headers, statusText])\n   *      | function(function(method, url, data, headers, params)}\n   *      ```\n   *    – The respond method takes a set of static data to be returned or a function that can\n   *    return an array containing response status (number), response data (Array|Object|string),\n   *    response headers (Object), and the text for the status (string). The respond method returns\n   *    the `requestHandler` object for possible overrides.\n   */\n  $httpBackend.when = function(method, url, data, headers, keys) {\n    var definition = new MockHttpExpectation(method, url, data, headers, keys),\n        chain = {\n          respond: function(status, data, headers, statusText) {\n            definition.passThrough = undefined;\n            definition.response = createResponse(status, data, headers, statusText);\n            return chain;\n          }\n        };\n\n    if ($browser) {\n      chain.passThrough = function() {\n        definition.response = undefined;\n        definition.passThrough = true;\n        return chain;\n      };\n    }\n\n    definitions.push(definition);\n    return chain;\n  };\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenGET\n   * @description\n   * Creates a new backend definition for GET requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenHEAD\n   * @description\n   * Creates a new backend definition for HEAD requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenDELETE\n   * @description\n   * Creates a new backend definition for DELETE requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenPOST\n   * @description\n   * Creates a new backend definition for POST requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n   *   data string and returns true if the data is as expected.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenPUT\n   * @description\n   * Creates a new backend definition for PUT requests.  For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string))=} data HTTP request body or function that receives\n   *   data string and returns true if the data is as expected.\n   * @param {(Object|function(Object))=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenJSONP\n   * @description\n   * Creates a new backend definition for JSONP requests. For more info see `when()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled.\n   */\n  createShortMethods('when');\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#whenRoute\n   * @description\n   * Creates a new backend definition that compares only with the requested route.\n   *\n   * @param {string} method HTTP method.\n   * @param {string} url HTTP url string that supports colon param matching.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled. See #when for more info.\n   */\n  $httpBackend.whenRoute = function(method, url) {\n    var pathObj = parseRoute(url);\n    return $httpBackend.when(method, pathObj.regexp, undefined, undefined, pathObj.keys);\n  };\n\n  function parseRoute(url) {\n    var ret = {\n      regexp: url\n    },\n    keys = ret.keys = [];\n\n    if (!url || !angular.isString(url)) return ret;\n\n    url = url\n      .replace(/([().])/g, '\\\\$1')\n      .replace(/(\\/)?:(\\w+)([\\?\\*])?/g, function(_, slash, key, option) {\n        var optional = option === '?' ? option : null;\n        var star = option === '*' ? option : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (star && '(.+?)' || '([^/]+)')\n          + (optional || '')\n          + ')'\n          + (optional || '');\n      })\n      .replace(/([\\/$\\*])/g, '\\\\$1');\n\n    ret.regexp = new RegExp('^' + url, 'i');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expect\n   * @description\n   * Creates a new request expectation.\n   *\n   * @param {string} method HTTP method.\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\n   *   object and returns true if the headers match the current expectation.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *  request is handled. You can save this object for later use and invoke `respond` again in\n   *  order to change how a matched request is handled.\n   *\n   *  - respond –\n   *    ```\n   *    { function([status,] data[, headers, statusText])\n   *    | function(function(method, url, data, headers, params)}\n   *    ```\n   *    – The respond method takes a set of static data to be returned or a function that can\n   *    return an array containing response status (number), response data (Array|Object|string),\n   *    response headers (Object), and the text for the status (string). The respond method returns\n   *    the `requestHandler` object for possible overrides.\n   */\n  $httpBackend.expect = function(method, url, data, headers, keys) {\n    var expectation = new MockHttpExpectation(method, url, data, headers, keys),\n        chain = {\n          respond: function(status, data, headers, statusText) {\n            expectation.response = createResponse(status, data, headers, statusText);\n            return chain;\n          }\n        };\n\n    expectations.push(expectation);\n    return chain;\n  };\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectGET\n   * @description\n   * Creates a new request expectation for GET requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled. See #expect for more info.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectHEAD\n   * @description\n   * Creates a new request expectation for HEAD requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectDELETE\n   * @description\n   * Creates a new request expectation for DELETE requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectPOST\n   * @description\n   * Creates a new request expectation for POST requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectPUT\n   * @description\n   * Creates a new request expectation for PUT requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectPATCH\n   * @description\n   * Creates a new request expectation for PATCH requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n   *   and returns true if the url matches the current definition.\n   * @param {(string|RegExp|function(string)|Object)=} data HTTP request body or function that\n   *  receives data string and returns true if the data is as expected, or Object if request body\n   *  is in JSON format.\n   * @param {Object=} headers HTTP headers.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectJSONP\n   * @description\n   * Creates a new request expectation for JSONP requests. For more info see `expect()`.\n   *\n   * @param {string|RegExp|function(string)} url HTTP url or function that receives an url\n   *   and returns true if the url matches the current definition.\n   * @param {(Array)=} keys Array of keys to assign to regex matches in request url described above.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   *   request is handled. You can save this object for later use and invoke `respond` again in\n   *   order to change how a matched request is handled.\n   */\n  createShortMethods('expect');\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#expectRoute\n   * @description\n   * Creates a new request expectation that compares only with the requested route.\n   *\n   * @param {string} method HTTP method.\n   * @param {string} url HTTP url string that supports colon param matching.\n   * @returns {requestHandler} Returns an object with `respond` method that controls how a matched\n   * request is handled. You can save this object for later use and invoke `respond` again in\n   * order to change how a matched request is handled. See #expect for more info.\n   */\n  $httpBackend.expectRoute = function(method, url) {\n    var pathObj = parseRoute(url);\n    return $httpBackend.expect(method, pathObj.regexp, undefined, undefined, pathObj.keys);\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#flush\n   * @description\n   * Flushes all pending requests using the trained responses.\n   *\n   * @param {number=} count Number of responses to flush (in the order they arrived). If undefined,\n   *   all pending requests will be flushed. If there are no pending requests when the flush method\n   *   is called an exception is thrown (as this typically a sign of programming error).\n   */\n  $httpBackend.flush = function(count, digest) {\n    if (digest !== false) $rootScope.$digest();\n    if (!responses.length) throw new Error('No pending request to flush !');\n\n    if (angular.isDefined(count) && count !== null) {\n      while (count--) {\n        if (!responses.length) throw new Error('No more pending request to flush !');\n        responses.shift()();\n      }\n    } else {\n      while (responses.length) {\n        responses.shift()();\n      }\n    }\n    $httpBackend.verifyNoOutstandingExpectation(digest);\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#verifyNoOutstandingExpectation\n   * @description\n   * Verifies that all of the requests defined via the `expect` api were made. If any of the\n   * requests were not made, verifyNoOutstandingExpectation throws an exception.\n   *\n   * Typically, you would call this method following each test case that asserts requests using an\n   * \"afterEach\" clause.\n   *\n   * ```js\n   *   afterEach($httpBackend.verifyNoOutstandingExpectation);\n   * ```\n   */\n  $httpBackend.verifyNoOutstandingExpectation = function(digest) {\n    if (digest !== false) $rootScope.$digest();\n    if (expectations.length) {\n      throw new Error('Unsatisfied requests: ' + expectations.join(', '));\n    }\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#verifyNoOutstandingRequest\n   * @description\n   * Verifies that there are no outstanding requests that need to be flushed.\n   *\n   * Typically, you would call this method following each test case that asserts requests using an\n   * \"afterEach\" clause.\n   *\n   * ```js\n   *   afterEach($httpBackend.verifyNoOutstandingRequest);\n   * ```\n   */\n  $httpBackend.verifyNoOutstandingRequest = function() {\n    if (responses.length) {\n      throw new Error('Unflushed requests: ' + responses.length);\n    }\n  };\n\n\n  /**\n   * @ngdoc method\n   * @name $httpBackend#resetExpectations\n   * @description\n   * Resets all request expectations, but preserves all backend definitions. Typically, you would\n   * call resetExpectations during a multiple-phase test when you want to reuse the same instance of\n   * $httpBackend mock.\n   */\n  $httpBackend.resetExpectations = function() {\n    expectations.length = 0;\n    responses.length = 0;\n  };\n\n  return $httpBackend;\n\n\n  function createShortMethods(prefix) {\n    angular.forEach(['GET', 'DELETE', 'JSONP', 'HEAD'], function(method) {\n     $httpBackend[prefix + method] = function(url, headers, keys) {\n       return $httpBackend[prefix](method, url, undefined, headers, keys);\n     };\n    });\n\n    angular.forEach(['PUT', 'POST', 'PATCH'], function(method) {\n      $httpBackend[prefix + method] = function(url, data, headers, keys) {\n        return $httpBackend[prefix](method, url, data, headers, keys);\n      };\n    });\n  }\n}\n\nfunction MockHttpExpectation(method, url, data, headers, keys) {\n\n  function getUrlParams(u) {\n    var params = u.slice(u.indexOf('?') + 1).split('&');\n    return params.sort();\n  }\n\n  function compareUrl(u) {\n    return (url.slice(0, url.indexOf('?')) == u.slice(0, u.indexOf('?')) && getUrlParams(url).join() == getUrlParams(u).join());\n  }\n\n  this.data = data;\n  this.headers = headers;\n\n  this.match = function(m, u, d, h) {\n    if (method != m) return false;\n    if (!this.matchUrl(u)) return false;\n    if (angular.isDefined(d) && !this.matchData(d)) return false;\n    if (angular.isDefined(h) && !this.matchHeaders(h)) return false;\n    return true;\n  };\n\n  this.matchUrl = function(u) {\n    if (!url) return true;\n    if (angular.isFunction(url.test)) return url.test(u);\n    if (angular.isFunction(url)) return url(u);\n    return (url == u || compareUrl(u));\n  };\n\n  this.matchHeaders = function(h) {\n    if (angular.isUndefined(headers)) return true;\n    if (angular.isFunction(headers)) return headers(h);\n    return angular.equals(headers, h);\n  };\n\n  this.matchData = function(d) {\n    if (angular.isUndefined(data)) return true;\n    if (data && angular.isFunction(data.test)) return data.test(d);\n    if (data && angular.isFunction(data)) return data(d);\n    if (data && !angular.isString(data)) {\n      return angular.equals(angular.fromJson(angular.toJson(data)), angular.fromJson(d));\n    }\n    return data == d;\n  };\n\n  this.toString = function() {\n    return method + ' ' + url;\n  };\n\n  this.params = function(u) {\n    return angular.extend(parseQuery(), pathParams());\n\n    function pathParams() {\n      var keyObj = {};\n      if (!url || !angular.isFunction(url.test) || !keys || keys.length === 0) return keyObj;\n\n      var m = url.exec(u);\n      if (!m) return keyObj;\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n        var val = m[i];\n        if (key && val) {\n          keyObj[key.name || key] = val;\n        }\n      }\n\n      return keyObj;\n    }\n\n    function parseQuery() {\n      var obj = {}, key_value, key,\n          queryStr = u.indexOf('?') > -1\n          ? u.substring(u.indexOf('?') + 1)\n          : \"\";\n\n      angular.forEach(queryStr.split('&'), function(keyValue) {\n        if (keyValue) {\n          key_value = keyValue.replace(/\\+/g,'%20').split('=');\n          key = tryDecodeURIComponent(key_value[0]);\n          if (angular.isDefined(key)) {\n            var val = angular.isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;\n            if (!hasOwnProperty.call(obj, key)) {\n              obj[key] = val;\n            } else if (angular.isArray(obj[key])) {\n              obj[key].push(val);\n            } else {\n              obj[key] = [obj[key],val];\n            }\n          }\n        }\n      });\n      return obj;\n    }\n    function tryDecodeURIComponent(value) {\n      try {\n        return decodeURIComponent(value);\n      } catch (e) {\n        // Ignore any invalid uri component\n      }\n    }\n  };\n}\n\nfunction createMockXhr() {\n  return new MockXhr();\n}\n\nfunction MockXhr() {\n\n  // hack for testing $http, $httpBackend\n  MockXhr.$$lastInstance = this;\n\n  this.open = function(method, url, async) {\n    this.$$method = method;\n    this.$$url = url;\n    this.$$async = async;\n    this.$$reqHeaders = {};\n    this.$$respHeaders = {};\n  };\n\n  this.send = function(data) {\n    this.$$data = data;\n  };\n\n  this.setRequestHeader = function(key, value) {\n    this.$$reqHeaders[key] = value;\n  };\n\n  this.getResponseHeader = function(name) {\n    // the lookup must be case insensitive,\n    // that's why we try two quick lookups first and full scan last\n    var header = this.$$respHeaders[name];\n    if (header) return header;\n\n    name = angular.lowercase(name);\n    header = this.$$respHeaders[name];\n    if (header) return header;\n\n    header = undefined;\n    angular.forEach(this.$$respHeaders, function(headerVal, headerName) {\n      if (!header && angular.lowercase(headerName) == name) header = headerVal;\n    });\n    return header;\n  };\n\n  this.getAllResponseHeaders = function() {\n    var lines = [];\n\n    angular.forEach(this.$$respHeaders, function(value, key) {\n      lines.push(key + ': ' + value);\n    });\n    return lines.join('\\n');\n  };\n\n  this.abort = angular.noop;\n\n  // This section simulates the events on a real XHR object (and the upload object)\n  // When we are testing $httpBackend (inside the angular project) we make partial use of this\n  // but store the events directly ourselves on `$$events`, instead of going through the `addEventListener`\n  this.$$events = {};\n  this.addEventListener = function(name, listener) {\n    if (angular.isUndefined(this.$$events[name])) this.$$events[name] = [];\n    this.$$events[name].push(listener);\n  };\n\n  this.upload = {\n    $$events: {},\n    addEventListener: this.addEventListener\n  };\n}\n\n\n/**\n * @ngdoc service\n * @name $timeout\n * @description\n *\n * This service is just a simple decorator for {@link ng.$timeout $timeout} service\n * that adds a \"flush\" and \"verifyNoPendingTasks\" methods.\n */\n\nangular.mock.$TimeoutDecorator = ['$delegate', '$browser', function($delegate, $browser) {\n\n  /**\n   * @ngdoc method\n   * @name $timeout#flush\n   * @description\n   *\n   * Flushes the queue of pending tasks.\n   *\n   * @param {number=} delay maximum timeout amount to flush up until\n   */\n  $delegate.flush = function(delay) {\n    $browser.defer.flush(delay);\n  };\n\n  /**\n   * @ngdoc method\n   * @name $timeout#verifyNoPendingTasks\n   * @description\n   *\n   * Verifies that there are no pending tasks that need to be flushed.\n   */\n  $delegate.verifyNoPendingTasks = function() {\n    if ($browser.deferredFns.length) {\n      throw new Error('Deferred tasks to flush (' + $browser.deferredFns.length + '): ' +\n          formatPendingTasksAsString($browser.deferredFns));\n    }\n  };\n\n  function formatPendingTasksAsString(tasks) {\n    var result = [];\n    angular.forEach(tasks, function(task) {\n      result.push('{id: ' + task.id + ', ' + 'time: ' + task.time + '}');\n    });\n\n    return result.join(', ');\n  }\n\n  return $delegate;\n}];\n\nangular.mock.$RAFDecorator = ['$delegate', function($delegate) {\n  var rafFn = function(fn) {\n    var index = rafFn.queue.length;\n    rafFn.queue.push(fn);\n    return function() {\n      rafFn.queue.splice(index, 1);\n    };\n  };\n\n  rafFn.queue = [];\n  rafFn.supported = $delegate.supported;\n\n  rafFn.flush = function() {\n    if (rafFn.queue.length === 0) {\n      throw new Error('No rAF callbacks present');\n    }\n\n    var length = rafFn.queue.length;\n    for (var i = 0; i < length; i++) {\n      rafFn.queue[i]();\n    }\n\n    rafFn.queue = rafFn.queue.slice(i);\n  };\n\n  return rafFn;\n}];\n\n/**\n *\n */\nvar originalRootElement;\nangular.mock.$RootElementProvider = function() {\n  this.$get = ['$injector', function($injector) {\n    originalRootElement = angular.element('<div ng-app></div>').data('$injector', $injector);\n    return originalRootElement;\n  }];\n};\n\n/**\n * @ngdoc service\n * @name $controller\n * @description\n * A decorator for {@link ng.$controller} with additional `bindings` parameter, useful when testing\n * controllers of directives that use {@link $compile#-bindtocontroller- `bindToController`}.\n *\n *\n * ## Example\n *\n * ```js\n *\n * // Directive definition ...\n *\n * myMod.directive('myDirective', {\n *   controller: 'MyDirectiveController',\n *   bindToController: {\n *     name: '@'\n *   }\n * });\n *\n *\n * // Controller definition ...\n *\n * myMod.controller('MyDirectiveController', ['$log', function($log) {\n *   $log.info(this.name);\n * }]);\n *\n *\n * // In a test ...\n *\n * describe('myDirectiveController', function() {\n *   it('should write the bound name to the log', inject(function($controller, $log) {\n *     var ctrl = $controller('MyDirectiveController', { /* no locals &#42;/ }, { name: 'Clark Kent' });\n *     expect(ctrl.name).toEqual('Clark Kent');\n *     expect($log.info.logs).toEqual(['Clark Kent']);\n *   }));\n * });\n *\n * ```\n *\n * @param {Function|string} constructor If called with a function then it's considered to be the\n *    controller constructor function. Otherwise it's considered to be a string which is used\n *    to retrieve the controller constructor using the following steps:\n *\n *    * check if a controller with given name is registered via `$controllerProvider`\n *    * check if evaluating the string on the current scope returns a constructor\n *    * if $controllerProvider#allowGlobals, check `window[constructor]` on the global\n *      `window` object (not recommended)\n *\n *    The string can use the `controller as property` syntax, where the controller instance is published\n *    as the specified property on the `scope`; the `scope` must be injected into `locals` param for this\n *    to work correctly.\n *\n * @param {Object} locals Injection locals for Controller.\n * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used\n *                           to simulate the `bindToController` feature and simplify certain kinds of tests.\n * @return {Object} Instance of given controller.\n */\nangular.mock.$ControllerDecorator = ['$delegate', function($delegate) {\n  return function(expression, locals, later, ident) {\n    if (later && typeof later === 'object') {\n      var instantiate = $delegate(expression, locals, true, ident);\n      angular.extend(instantiate.instance, later);\n\n      var instance = instantiate();\n      if (instance !== instantiate.instance) {\n        angular.extend(instance, later);\n      }\n\n      return instance;\n    }\n    return $delegate(expression, locals, later, ident);\n  };\n}];\n\n/**\n * @ngdoc service\n * @name $componentController\n * @description\n * A service that can be used to create instances of component controllers.\n * <div class=\"alert alert-info\">\n * Be aware that the controller will be instantiated and attached to the scope as specified in\n * the component definition object. If you do not provide a `$scope` object in the `locals` param\n * then the helper will create a new isolated scope as a child of `$rootScope`.\n * </div>\n * @param {string} componentName the name of the component whose controller we want to instantiate\n * @param {Object} locals Injection locals for Controller.\n * @param {Object=} bindings Properties to add to the controller before invoking the constructor. This is used\n *                           to simulate the `bindToController` feature and simplify certain kinds of tests.\n * @param {string=} ident Override the property name to use when attaching the controller to the scope.\n * @return {Object} Instance of requested controller.\n */\nangular.mock.$ComponentControllerProvider = ['$compileProvider', function($compileProvider) {\n  this.$get = ['$controller','$injector', '$rootScope', function($controller, $injector, $rootScope) {\n    return function $componentController(componentName, locals, bindings, ident) {\n      // get all directives associated to the component name\n      var directives = $injector.get(componentName + 'Directive');\n      // look for those directives that are components\n      var candidateDirectives = directives.filter(function(directiveInfo) {\n        // components have controller, controllerAs and restrict:'E'\n        return directiveInfo.controller && directiveInfo.controllerAs && directiveInfo.restrict === 'E';\n      });\n      // check if valid directives found\n      if (candidateDirectives.length === 0) {\n        throw new Error('No component found');\n      }\n      if (candidateDirectives.length > 1) {\n        throw new Error('Too many components found');\n      }\n      // get the info of the component\n      var directiveInfo = candidateDirectives[0];\n      // create a scope if needed\n      locals = locals || {};\n      locals.$scope = locals.$scope || $rootScope.$new(true);\n      return $controller(directiveInfo.controller, locals, bindings, ident || directiveInfo.controllerAs);\n    };\n  }];\n}];\n\n\n/**\n * @ngdoc module\n * @name ngMock\n * @packageName angular-mocks\n * @description\n *\n * # ngMock\n *\n * The `ngMock` module provides support to inject and mock Angular services into unit tests.\n * In addition, ngMock also extends various core ng services such that they can be\n * inspected and controlled in a synchronous manner within test code.\n *\n *\n * <div doc-module-components=\"ngMock\"></div>\n *\n * @installation\n *\n *  First, download the file:\n *  * [Google CDN](https://developers.google.com/speed/libraries/devguide#angularjs) e.g.\n *    `\"//ajax.googleapis.com/ajax/libs/angularjs/X.Y.Z/angular-mocks.js\"`\n *  * [NPM](https://www.npmjs.com/) e.g. `npm install angular-mocks@X.Y.Z`\n *  * [Bower](http://bower.io) e.g. `bower install angular-mocks#X.Y.Z`\n *  * [code.angularjs.org](https://code.angularjs.org/) (discouraged for production use)  e.g.\n *    `\"//code.angularjs.org/X.Y.Z/angular-mocks.js\"`\n *\n * where X.Y.Z is the AngularJS version you are running.\n *\n * Then, configure your test runner to load `angular-mocks.js` after `angular.js`.\n * This example uses <a href=\"http://karma-runner.github.io/\">Karma</a>:\n *\n * ```\n * config.set({\n *   files: [\n *     'build/angular.js', // and other module files you need\n *     'build/angular-mocks.js',\n *     '<path/to/application/files>',\n *     '<path/to/spec/files>'\n *   ]\n * });\n * ```\n *\n * Including the `angular-mocks.js` file automatically adds the `ngMock` module, so your tests\n *  are ready to go!\n */\nangular.module('ngMock', ['ng']).provider({\n  $browser: angular.mock.$BrowserProvider,\n  $exceptionHandler: angular.mock.$ExceptionHandlerProvider,\n  $log: angular.mock.$LogProvider,\n  $interval: angular.mock.$IntervalProvider,\n  $httpBackend: angular.mock.$HttpBackendProvider,\n  $rootElement: angular.mock.$RootElementProvider,\n  $componentController: angular.mock.$ComponentControllerProvider\n}).config(['$provide', function($provide) {\n  $provide.decorator('$timeout', angular.mock.$TimeoutDecorator);\n  $provide.decorator('$$rAF', angular.mock.$RAFDecorator);\n  $provide.decorator('$rootScope', angular.mock.$RootScopeDecorator);\n  $provide.decorator('$controller', angular.mock.$ControllerDecorator);\n}]);\n\n/**\n * @ngdoc module\n * @name ngMockE2E\n * @module ngMockE2E\n * @packageName angular-mocks\n * @description\n *\n * The `ngMockE2E` is an angular module which contains mocks suitable for end-to-end testing.\n * Currently there is only one mock present in this module -\n * the {@link ngMockE2E.$httpBackend e2e $httpBackend} mock.\n */\nangular.module('ngMockE2E', ['ng']).config(['$provide', function($provide) {\n  $provide.value('$httpBackend', angular.injector(['ng']).get('$httpBackend'));\n  $provide.decorator('$httpBackend', angular.mock.e2e.$httpBackendDecorator);\n}]);\n\n/**\n * @ngdoc service\n * @name $httpBackend\n * @module ngMockE2E\n * @description\n * Fake HTTP backend implementation suitable for end-to-end testing or backend-less development of\n * applications that use the {@link ng.$http $http service}.\n *\n * <div class=\"alert alert-info\">\n * **Note**: For fake http backend implementation suitable for unit testing please see\n * {@link ngMock.$httpBackend unit-testing $httpBackend mock}.\n * </div>\n *\n * This implementation can be used to respond with static or dynamic responses via the `when` api\n * and its shortcuts (`whenGET`, `whenPOST`, etc) and optionally pass through requests to the\n * real $httpBackend for specific requests (e.g. to interact with certain remote apis or to fetch\n * templates from a webserver).\n *\n * As opposed to unit-testing, in an end-to-end testing scenario or in scenario when an application\n * is being developed with the real backend api replaced with a mock, it is often desirable for\n * certain category of requests to bypass the mock and issue a real http request (e.g. to fetch\n * templates or static files from the webserver). To configure the backend with this behavior\n * use the `passThrough` request handler of `when` instead of `respond`.\n *\n * Additionally, we don't want to manually have to flush mocked out requests like we do during unit\n * testing. For this reason the e2e $httpBackend flushes mocked out requests\n * automatically, closely simulating the behavior of the XMLHttpRequest object.\n *\n * To setup the application to run with this http backend, you have to create a module that depends\n * on the `ngMockE2E` and your application modules and defines the fake backend:\n *\n * ```js\n *   var myAppDev = angular.module('myAppDev', ['myApp', 'ngMockE2E']);\n *   myAppDev.run(function($httpBackend) {\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\n *\n *     // returns the current list of phones\n *     $httpBackend.whenGET('/phones').respond(phones);\n *\n *     // adds a new phone to the phones array\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\n *       var phone = angular.fromJson(data);\n *       phones.push(phone);\n *       return [200, phone, {}];\n *     });\n *     $httpBackend.whenGET(/^\\/templates\\//).passThrough(); // Requests for templare are handled by the real server\n *     //...\n *   });\n * ```\n *\n * Afterwards, bootstrap your app with this new module.\n *\n * ## Example\n * <example name=\"httpbackend-e2e-testing\" module=\"myAppE2E\" deps=\"angular-mocks.js\">\n * <file name=\"app.js\">\n *   var myApp = angular.module('myApp', []);\n *\n *   myApp.controller('main', function($http) {\n *     var ctrl = this;\n *\n *     ctrl.phones = [];\n *     ctrl.newPhone = {\n *       name: ''\n *     };\n *\n *     ctrl.getPhones = function() {\n *       $http.get('/phones').then(function(response) {\n *         ctrl.phones = response.data;\n *       });\n *     };\n *\n *     ctrl.addPhone = function(phone) {\n *       $http.post('/phones', phone).then(function() {\n *         ctrl.newPhone = {name: ''};\n *         return ctrl.getPhones();\n *       });\n *     };\n *\n *     ctrl.getPhones();\n *   });\n * </file>\n * <file name=\"e2e.js\">\n *   var myAppDev = angular.module('myAppE2E', ['myApp', 'ngMockE2E']);\n *\n *   myAppDev.run(function($httpBackend) {\n *     var phones = [{name: 'phone1'}, {name: 'phone2'}];\n *\n *     // returns the current list of phones\n *     $httpBackend.whenGET('/phones').respond(phones);\n *\n *     // adds a new phone to the phones array\n *     $httpBackend.whenPOST('/phones').respond(function(method, url, data) {\n *       var phone = angular.fromJson(data);\n *       phones.push(phone);\n *       return [200, phone, {}];\n *     });\n *   });\n * </file>\n * <file name=\"index.html\">\n *   <div ng-controller=\"main as $ctrl\">\n *   <form name=\"newPhoneForm\" ng-submit=\"$ctrl.addPhone($ctrl.newPhone)\">\n *     <input type=\"text\" ng-model=\"$ctrl.newPhone.name\">\n *     <input type=\"submit\" value=\"Add Phone\">\n *   </form>\n *   <h1>Phones</h1>\n *   <ul>\n *     <li ng-repeat=\"phone in $ctrl.phones\">{{phone.name}}</li>\n *   </ul>\n *   </div>\n * </file>\n * </example>\n *\n *\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#when\n * @module ngMockE2E\n * @description\n * Creates a new backend definition.\n *\n * @param {string} method HTTP method.\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp)=} data HTTP request body.\n * @param {(Object|function(Object))=} headers HTTP headers or function that receives http header\n *   object and returns true if the headers match the current definition.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n *\n *  - respond –\n *    ```\n *    { function([status,] data[, headers, statusText])\n *    | function(function(method, url, data, headers, params)}\n *    ```\n *    – The respond method takes a set of static data to be returned or a function that can return\n *    an array containing response status (number), response data (Array|Object|string), response\n *    headers (Object), and the text for the status (string).\n *  - passThrough – `{function()}` – Any request matching a backend definition with\n *    `passThrough` handler will be passed through to the real backend (an XHR request will be made\n *    to the server.)\n *  - Both methods return the `requestHandler` object for possible overrides.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenGET\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for GET requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenHEAD\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for HEAD requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenDELETE\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for DELETE requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenPOST\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for POST requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp)=} data HTTP request body.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenPUT\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for PUT requests.  For more info see `when()`.\n *\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp)=} data HTTP request body.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenPATCH\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for PATCH requests.  For more info see `when()`.\n *\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(string|RegExp)=} data HTTP request body.\n * @param {(Object|function(Object))=} headers HTTP headers.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n\n/**\n * @ngdoc method\n * @name $httpBackend#whenJSONP\n * @module ngMockE2E\n * @description\n * Creates a new backend definition for JSONP requests. For more info see `when()`.\n *\n * @param {string|RegExp|function(string)} url HTTP url or function that receives a url\n *   and returns true if the url matches the current definition.\n * @param {(Array)=} keys Array of keys to assign to regex matches in request url described on\n *   {@link ngMock.$httpBackend $httpBackend mock}.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\n/**\n * @ngdoc method\n * @name $httpBackend#whenRoute\n * @module ngMockE2E\n * @description\n * Creates a new backend definition that compares only with the requested route.\n *\n * @param {string} method HTTP method.\n * @param {string} url HTTP url string that supports colon param matching.\n * @returns {requestHandler} Returns an object with `respond` and `passThrough` methods that\n *   control how a matched request is handled. You can save this object for later use and invoke\n *   `respond` or `passThrough` again in order to change how a matched request is handled.\n */\nangular.mock.e2e = {};\nangular.mock.e2e.$httpBackendDecorator =\n  ['$rootScope', '$timeout', '$delegate', '$browser', createHttpBackendMock];\n\n\n/**\n * @ngdoc type\n * @name $rootScope.Scope\n * @module ngMock\n * @description\n * {@link ng.$rootScope.Scope Scope} type decorated with helper methods useful for testing. These\n * methods are automatically available on any {@link ng.$rootScope.Scope Scope} instance when\n * `ngMock` module is loaded.\n *\n * In addition to all the regular `Scope` methods, the following helper methods are available:\n */\nangular.mock.$RootScopeDecorator = ['$delegate', function($delegate) {\n\n  var $rootScopePrototype = Object.getPrototypeOf($delegate);\n\n  $rootScopePrototype.$countChildScopes = countChildScopes;\n  $rootScopePrototype.$countWatchers = countWatchers;\n\n  return $delegate;\n\n  // ------------------------------------------------------------------------------------------ //\n\n  /**\n   * @ngdoc method\n   * @name $rootScope.Scope#$countChildScopes\n   * @module ngMock\n   * @description\n   * Counts all the direct and indirect child scopes of the current scope.\n   *\n   * The current scope is excluded from the count. The count includes all isolate child scopes.\n   *\n   * @returns {number} Total number of child scopes.\n   */\n  function countChildScopes() {\n    // jshint validthis: true\n    var count = 0; // exclude the current scope\n    var pendingChildHeads = [this.$$childHead];\n    var currentScope;\n\n    while (pendingChildHeads.length) {\n      currentScope = pendingChildHeads.shift();\n\n      while (currentScope) {\n        count += 1;\n        pendingChildHeads.push(currentScope.$$childHead);\n        currentScope = currentScope.$$nextSibling;\n      }\n    }\n\n    return count;\n  }\n\n\n  /**\n   * @ngdoc method\n   * @name $rootScope.Scope#$countWatchers\n   * @module ngMock\n   * @description\n   * Counts all the watchers of direct and indirect child scopes of the current scope.\n   *\n   * The watchers of the current scope are included in the count and so are all the watchers of\n   * isolate child scopes.\n   *\n   * @returns {number} Total number of watchers.\n   */\n  function countWatchers() {\n    // jshint validthis: true\n    var count = this.$$watchers ? this.$$watchers.length : 0; // include the current scope\n    var pendingChildHeads = [this.$$childHead];\n    var currentScope;\n\n    while (pendingChildHeads.length) {\n      currentScope = pendingChildHeads.shift();\n\n      while (currentScope) {\n        count += currentScope.$$watchers ? currentScope.$$watchers.length : 0;\n        pendingChildHeads.push(currentScope.$$childHead);\n        currentScope = currentScope.$$nextSibling;\n      }\n    }\n\n    return count;\n  }\n}];\n\n\n!(function(jasmineOrMocha) {\n\n  if (!jasmineOrMocha) {\n    return;\n  }\n\n  var currentSpec = null,\n      injectorState = new InjectorState(),\n      annotatedFunctions = [],\n      wasInjectorCreated = function() {\n        return !!currentSpec;\n      };\n\n  angular.mock.$$annotate = angular.injector.$$annotate;\n  angular.injector.$$annotate = function(fn) {\n    if (typeof fn === 'function' && !fn.$inject) {\n      annotatedFunctions.push(fn);\n    }\n    return angular.mock.$$annotate.apply(this, arguments);\n  };\n\n  /**\n   * @ngdoc function\n   * @name angular.mock.module\n   * @description\n   *\n   * *NOTE*: This function is also published on window for easy access.<br>\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\n   *\n   * This function registers a module configuration code. It collects the configuration information\n   * which will be used when the injector is created by {@link angular.mock.inject inject}.\n   *\n   * See {@link angular.mock.inject inject} for usage example\n   *\n   * @param {...(string|Function|Object)} fns any number of modules which are represented as string\n   *        aliases or as anonymous module initialization functions. The modules are used to\n   *        configure the injector. The 'ng' and 'ngMock' modules are automatically loaded. If an\n   *        object literal is passed each key-value pair will be registered on the module via\n   *        {@link auto.$provide $provide}.value, the key being the string name (or token) to associate\n   *        with the value on the injector.\n   */\n  var module = window.module = angular.mock.module = function() {\n    var moduleFns = Array.prototype.slice.call(arguments, 0);\n    return wasInjectorCreated() ? workFn() : workFn;\n    /////////////////////\n    function workFn() {\n      if (currentSpec.$injector) {\n        throw new Error('Injector already created, can not register a module!');\n      } else {\n        var fn, modules = currentSpec.$modules || (currentSpec.$modules = []);\n        angular.forEach(moduleFns, function(module) {\n          if (angular.isObject(module) && !angular.isArray(module)) {\n            fn = ['$provide', function($provide) {\n              angular.forEach(module, function(value, key) {\n                $provide.value(key, value);\n              });\n            }];\n          } else {\n            fn = module;\n          }\n          if (currentSpec.$providerInjector) {\n            currentSpec.$providerInjector.invoke(fn);\n          } else {\n            modules.push(fn);\n          }\n        });\n      }\n    }\n  };\n\n  module.$$beforeAllHook = (window.before || window.beforeAll);\n  module.$$afterAllHook = (window.after || window.afterAll);\n\n  // purely for testing ngMock itself\n  module.$$currentSpec = function(to) {\n    if (arguments.length === 0) return to;\n    currentSpec = to;\n  };\n\n  /**\n   * @ngdoc function\n   * @name angular.mock.module.sharedInjector\n   * @description\n   *\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\n   *\n   * This function ensures a single injector will be used for all tests in a given describe context.\n   * This contrasts with the default behaviour where a new injector is created per test case.\n   *\n   * Use sharedInjector when you want to take advantage of Jasmine's `beforeAll()`, or mocha's\n   * `before()` methods. Call `module.sharedInjector()` before you setup any other hooks that\n   * will create (i.e call `module()`) or use (i.e call `inject()`) the injector.\n   *\n   * You cannot call `sharedInjector()` from within a context already using `sharedInjector()`.\n   *\n   * ## Example\n   *\n   * Typically beforeAll is used to make many assertions about a single operation. This can\n   * cut down test run-time as the test setup doesn't need to be re-run, and enabling focussed\n   * tests each with a single assertion.\n   *\n   * ```js\n   * describe(\"Deep Thought\", function() {\n   *\n   *   module.sharedInjector();\n   *\n   *   beforeAll(module(\"UltimateQuestion\"));\n   *\n   *   beforeAll(inject(function(DeepThought) {\n   *     expect(DeepThought.answer).toBeUndefined();\n   *     DeepThought.generateAnswer();\n   *   }));\n   *\n   *   it(\"has calculated the answer correctly\", inject(function(DeepThought) {\n   *     // Because of sharedInjector, we have access to the instance of the DeepThought service\n   *     // that was provided to the beforeAll() hook. Therefore we can test the generated answer\n   *     expect(DeepThought.answer).toBe(42);\n   *   }));\n   *\n   *   it(\"has calculated the answer within the expected time\", inject(function(DeepThought) {\n   *     expect(DeepThought.runTimeMillennia).toBeLessThan(8000);\n   *   }));\n   *\n   *   it(\"has double checked the answer\", inject(function(DeepThought) {\n   *     expect(DeepThought.absolutelySureItIsTheRightAnswer).toBe(true);\n   *   }));\n   *\n   * });\n   *\n   * ```\n   */\n  module.sharedInjector = function() {\n    if (!(module.$$beforeAllHook && module.$$afterAllHook)) {\n      throw Error(\"sharedInjector() cannot be used unless your test runner defines beforeAll/afterAll\");\n    }\n\n    var initialized = false;\n\n    module.$$beforeAllHook(function() {\n      if (injectorState.shared) {\n        injectorState.sharedError = Error(\"sharedInjector() cannot be called inside a context that has already called sharedInjector()\");\n        throw injectorState.sharedError;\n      }\n      initialized = true;\n      currentSpec = this;\n      injectorState.shared = true;\n    });\n\n    module.$$afterAllHook(function() {\n      if (initialized) {\n        injectorState = new InjectorState();\n        module.$$cleanup();\n      } else {\n        injectorState.sharedError = null;\n      }\n    });\n  };\n\n  module.$$beforeEach = function() {\n    if (injectorState.shared && currentSpec && currentSpec != this) {\n      var state = currentSpec;\n      currentSpec = this;\n      angular.forEach([\"$injector\",\"$modules\",\"$providerInjector\", \"$injectorStrict\"], function(k) {\n        currentSpec[k] = state[k];\n        state[k] = null;\n      });\n    } else {\n      currentSpec = this;\n      originalRootElement = null;\n      annotatedFunctions = [];\n    }\n  };\n\n  module.$$afterEach = function() {\n    if (injectorState.cleanupAfterEach()) {\n      module.$$cleanup();\n    }\n  };\n\n  module.$$cleanup = function() {\n    var injector = currentSpec.$injector;\n\n    annotatedFunctions.forEach(function(fn) {\n      delete fn.$inject;\n    });\n\n    angular.forEach(currentSpec.$modules, function(module) {\n      if (module && module.$$hashKey) {\n        module.$$hashKey = undefined;\n      }\n    });\n\n    currentSpec.$injector = null;\n    currentSpec.$modules = null;\n    currentSpec.$providerInjector = null;\n    currentSpec = null;\n\n    if (injector) {\n      // Ensure `$rootElement` is instantiated, before checking `originalRootElement`\n      var $rootElement = injector.get('$rootElement');\n      var rootNode = $rootElement && $rootElement[0];\n      var cleanUpNodes = !originalRootElement ? [] : [originalRootElement[0]];\n      if (rootNode && (!originalRootElement || rootNode !== originalRootElement[0])) {\n        cleanUpNodes.push(rootNode);\n      }\n      angular.element.cleanData(cleanUpNodes);\n\n      // Ensure `$destroy()` is available, before calling it\n      // (a mocked `$rootScope` might not implement it (or not even be an object at all))\n      var $rootScope = injector.get('$rootScope');\n      if ($rootScope && $rootScope.$destroy) $rootScope.$destroy();\n    }\n\n    // clean up jquery's fragment cache\n    angular.forEach(angular.element.fragments, function(val, key) {\n      delete angular.element.fragments[key];\n    });\n\n    MockXhr.$$lastInstance = null;\n\n    angular.forEach(angular.callbacks, function(val, key) {\n      delete angular.callbacks[key];\n    });\n    angular.callbacks.$$counter = 0;\n  };\n\n  (window.beforeEach || window.setup)(module.$$beforeEach);\n  (window.afterEach || window.teardown)(module.$$afterEach);\n\n  /**\n   * @ngdoc function\n   * @name angular.mock.inject\n   * @description\n   *\n   * *NOTE*: This function is also published on window for easy access.<br>\n   * *NOTE*: This function is declared ONLY WHEN running tests with jasmine or mocha\n   *\n   * The inject function wraps a function into an injectable function. The inject() creates new\n   * instance of {@link auto.$injector $injector} per test, which is then used for\n   * resolving references.\n   *\n   *\n   * ## Resolving References (Underscore Wrapping)\n   * Often, we would like to inject a reference once, in a `beforeEach()` block and reuse this\n   * in multiple `it()` clauses. To be able to do this we must assign the reference to a variable\n   * that is declared in the scope of the `describe()` block. Since we would, most likely, want\n   * the variable to have the same name of the reference we have a problem, since the parameter\n   * to the `inject()` function would hide the outer variable.\n   *\n   * To help with this, the injected parameters can, optionally, be enclosed with underscores.\n   * These are ignored by the injector when the reference name is resolved.\n   *\n   * For example, the parameter `_myService_` would be resolved as the reference `myService`.\n   * Since it is available in the function body as _myService_, we can then assign it to a variable\n   * defined in an outer scope.\n   *\n   * ```\n   * // Defined out reference variable outside\n   * var myService;\n   *\n   * // Wrap the parameter in underscores\n   * beforeEach( inject( function(_myService_){\n   *   myService = _myService_;\n   * }));\n   *\n   * // Use myService in a series of tests.\n   * it('makes use of myService', function() {\n   *   myService.doStuff();\n   * });\n   *\n   * ```\n   *\n   * See also {@link angular.mock.module angular.mock.module}\n   *\n   * ## Example\n   * Example of what a typical jasmine tests looks like with the inject method.\n   * ```js\n   *\n   *   angular.module('myApplicationModule', [])\n   *       .value('mode', 'app')\n   *       .value('version', 'v1.0.1');\n   *\n   *\n   *   describe('MyApp', function() {\n   *\n   *     // You need to load modules that you want to test,\n   *     // it loads only the \"ng\" module by default.\n   *     beforeEach(module('myApplicationModule'));\n   *\n   *\n   *     // inject() is used to inject arguments of all given functions\n   *     it('should provide a version', inject(function(mode, version) {\n   *       expect(version).toEqual('v1.0.1');\n   *       expect(mode).toEqual('app');\n   *     }));\n   *\n   *\n   *     // The inject and module method can also be used inside of the it or beforeEach\n   *     it('should override a version and test the new version is injected', function() {\n   *       // module() takes functions or strings (module aliases)\n   *       module(function($provide) {\n   *         $provide.value('version', 'overridden'); // override version here\n   *       });\n   *\n   *       inject(function(version) {\n   *         expect(version).toEqual('overridden');\n   *       });\n   *     });\n   *   });\n   *\n   * ```\n   *\n   * @param {...Function} fns any number of functions which will be injected using the injector.\n   */\n\n\n\n  var ErrorAddingDeclarationLocationStack = function(e, errorForStack) {\n    this.message = e.message;\n    this.name = e.name;\n    if (e.line) this.line = e.line;\n    if (e.sourceId) this.sourceId = e.sourceId;\n    if (e.stack && errorForStack)\n      this.stack = e.stack + '\\n' + errorForStack.stack;\n    if (e.stackArray) this.stackArray = e.stackArray;\n  };\n  ErrorAddingDeclarationLocationStack.prototype = Error.prototype;\n\n  window.inject = angular.mock.inject = function() {\n    var blockFns = Array.prototype.slice.call(arguments, 0);\n    var errorForStack = new Error('Declaration Location');\n    // IE10+ and PhanthomJS do not set stack trace information, until the error is thrown\n    if (!errorForStack.stack) {\n      try {\n        throw errorForStack;\n      } catch (e) {}\n    }\n    return wasInjectorCreated() ? workFn.call(currentSpec) : workFn;\n    /////////////////////\n    function workFn() {\n      var modules = currentSpec.$modules || [];\n      var strictDi = !!currentSpec.$injectorStrict;\n      modules.unshift(['$injector', function($injector) {\n        currentSpec.$providerInjector = $injector;\n      }]);\n      modules.unshift('ngMock');\n      modules.unshift('ng');\n      var injector = currentSpec.$injector;\n      if (!injector) {\n        if (strictDi) {\n          // If strictDi is enabled, annotate the providerInjector blocks\n          angular.forEach(modules, function(moduleFn) {\n            if (typeof moduleFn === \"function\") {\n              angular.injector.$$annotate(moduleFn);\n            }\n          });\n        }\n        injector = currentSpec.$injector = angular.injector(modules, strictDi);\n        currentSpec.$injectorStrict = strictDi;\n      }\n      for (var i = 0, ii = blockFns.length; i < ii; i++) {\n        if (currentSpec.$injectorStrict) {\n          // If the injector is strict / strictDi, and the spec wants to inject using automatic\n          // annotation, then annotate the function here.\n          injector.annotate(blockFns[i]);\n        }\n        try {\n          /* jshint -W040 *//* Jasmine explicitly provides a `this` object when calling functions */\n          injector.invoke(blockFns[i] || angular.noop, this);\n          /* jshint +W040 */\n        } catch (e) {\n          if (e.stack && errorForStack) {\n            throw new ErrorAddingDeclarationLocationStack(e, errorForStack);\n          }\n          throw e;\n        } finally {\n          errorForStack = null;\n        }\n      }\n    }\n  };\n\n\n  angular.mock.inject.strictDi = function(value) {\n    value = arguments.length ? !!value : true;\n    return wasInjectorCreated() ? workFn() : workFn;\n\n    function workFn() {\n      if (value !== currentSpec.$injectorStrict) {\n        if (currentSpec.$injector) {\n          throw new Error('Injector already created, can not modify strict annotations');\n        } else {\n          currentSpec.$injectorStrict = value;\n        }\n      }\n    }\n  };\n\n  function InjectorState() {\n    this.shared = false;\n    this.sharedError = null;\n\n    this.cleanupAfterEach = function() {\n      return !this.shared || this.sharedError;\n    };\n  }\n})(window.jasmine || window.mocha);\n\n\n})(window, window.angular);\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/angular-mocks/angular-mocks.js\n **/"],"sourceRoot":""}